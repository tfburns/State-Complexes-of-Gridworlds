# -*- coding: utf-8 -*-
"""
@author: Tom
"""

import networkx as nx
import matplotlib.pyplot as plt
import pickle
import os
import copy
import numpy as np
import glob
import moviepy.editor as mpy
from natsort import natsorted

## load and plot a saved world graph constructed from worldbuilder.py

cwd = os.getcwd() # get current working directory

# list file-paths of files generated by woldbuilder.py
graph_path = os.path.normpath(cwd+"\\graph.gpickle")
node_positions_path = os.path.normpath(cwd+"\\node_positions")
node_IDs_path = os.path.normpath(cwd+"\\node_IDs")
node_orders_path = os.path.normpath(cwd+"\\node_orders")

# load variables
world_graph = nx.read_gpickle(graph_path)
infile = open(node_positions_path,'rb')
node_positions = pickle.load(infile)
infile.close()
infile = open(node_IDs_path,'rb')
node_IDs = pickle.load(infile)
infile.close()
infile = open(node_orders_path,'rb')
node_orders = pickle.load(infile)
infile.close()
WorldArea = world_graph.nodes()

# add colour information to the graph for special nodes
regular_colour = [0.5,0.5,0.5,0.5]
start_colour = [0,1,0,1]
goal_colour = [1,0,0,1]
object_colour = [0,0,1,1]
wall_colour = [1,1,1,0.5]

node_colours = []
for i in range(0,len(WorldArea)):
    node_colours.append(regular_colour)   

for k in node_orders[0]:
    node_colours[k] = start_colour
for k in node_orders[1]:
    node_colours[k] = goal_colour
for k in node_orders[2]:
    node_colours[k] = object_colour
for k in node_orders[3]:
    node_colours[k] = wall_colour

# plot the undirected graph
nx.draw_networkx(world_graph, pos=node_positions, node_color=node_colours)
plt.axis('off')
plt.show()


## start construction of state complex

# create state complex graph and set node counter
state_complex = nx.Graph()
state_complex_node_counter = 0

# set first state of state complex
state_complex.add_node(state_complex_node_counter, state=copy.deepcopy(node_IDs))

# set starting agent node
agent_node = node_IDs[0][0]

# GENERATOR 1
# agent (A) can move to adjacent node if it is empty (E), i.e. green -> grey
#   A-E
#   becomes
#   E-A

def gen_1_support(agent_node):
    agent_empty_neighbours = []
    print("## generator 1")
    for n in world_graph.neighbors(agent_node):
        if n in node_IDs[0]:
            print(n,'is an agent')
        elif n in node_IDs[1]:
            if n in node_IDs[2]:
                print(n,'is a goal but is blocked by an object')
            else:
                agent_empty_neighbours.append(n)
                print(n,'is a goal and is empty')
        elif n in node_IDs[2]:
            print(n,'is an object')
        elif n in node_IDs[3]:
            print(n,'is a wall')
        else:
            agent_empty_neighbours.append(n)
            print(n,'is empty')
    return agent_empty_neighbours

# GENERATOR 2
# agent (A) can push an object if there is empty space (E) behind the object (O), where *s represent any other node
#   A-O-E
#   *-*-*
#   becomes
#   E-A-O
#   *-*-*

def gen_2_support(agent_node):
    print("## generator 2")
    gen_2_possible = False
    
    object_loc = None
    adjacent_to_agent = []
    adjacent_to_object = []
    
    for n in world_graph.neighbors(agent_node):
        adjacent_to_agent.append(n)
        if n in node_IDs[2]:
            object_loc = n
            print("there is an adjacent object at node", object_loc)
    
    empty_adj_to_object = None
    object_movable_to = []
    agent_movable_to = []
    
    if object_loc:
        for m in world_graph.neighbors(object_loc):
            adjacent_to_object.append(m)
        
        for m in world_graph.neighbors(object_loc):
            not_agent = True
            if m == agent_node:
                not_agent = False
            
            if not_agent:
                if [m] not in node_IDs and m not in node_IDs[3]:
                    empty_adj_to_object = m
                    adjacent_to_empty = []
                
                    for n in world_graph.neighbors(empty_adj_to_object):
                        adjacent_to_empty.append(n)
                    
                    if set(adjacent_to_empty).intersection(set(adjacent_to_agent)) == set([object_loc]):
                        gen_2_possible = True
                        object_movable_to = m
                        agent_movable_to = object_loc
                        print("gen 2 possible! move agent to", agent_movable_to, "and object to", object_movable_to)

    return gen_2_possible, object_movable_to, agent_movable_to

# set-up and run the construction loop

todo = 0
todo_list = []
todo_list.append(todo)

todo_states = []
todo_states.append(copy.deepcopy(node_IDs))

step = 0

for x in todo_list:
    
    agent_nodes = copy.deepcopy(todo_states[x][0])
    if todo_states[x][2] == []:
        object_node = None
        node_IDs[2]= []
    else:
        object_node = copy.deepcopy(todo_states[x][2][0])
        node_IDs[2][0] = copy.deepcopy(object_node)
    
    print('### step', step,': agent at node', agent_nodes, 'and object at node', object_node)
    
    for agent in range(0,len(agent_nodes)):
        node_IDs[0] = copy.deepcopy(agent_nodes)
        agent_node = copy.deepcopy(todo_states[x][0][agent])
        node_IDs[0][agent] = copy.deepcopy(agent_node)

        # apply GENERATOR 1
        empty_neighbours = gen_1_support(agent_node)
        #last_agent = copy.deepcopy(agent_node)
        for e in empty_neighbours:
            print('test moving agent', agent_node, 'to empty neighbour', e)
            todo = len(todo_list)
            unique_node = True # assume this node will be unique
            node_IDs[0] = copy.deepcopy(agent_nodes)
            node_IDs[0].remove(agent_node) # remove current agent location
            node_IDs[0].append(e) # add empty neighbour to agent list
            #last_agent = e
            
            print('current', node_IDs)

            # if this node_IDs state exists in todo states, draw an edge to it
            for n in range(0,len(todo_states)):
                if set(node_IDs[0]) == set(todo_states[n][0]):
                    print('not unique')
                    unique_node = False # say that this node is not unique
                    state_complex.add_edge(x, n, attr='Gen 1') # create an edge to this existing state complex node
            
            # if this node_IDs state doesn't exist, create it and draw an edge
            if unique_node:
                print('unique')
                state_complex.add_node(todo, state=copy.deepcopy(node_IDs)) # create the new state complex node node
                state_complex.add_edge(x, todo, attr='Gen 1') # create an edge from the current node to this new node
                todo_states.append(copy.deepcopy(node_IDs))
                todo_list.append(todo)
        
        node_IDs[0] = copy.deepcopy(agent_nodes)
        
        # apply GENERATOR 2
        if object_node:
            
            gen_2_possible, object_movable_to, agent_movable_to = gen_2_support(agent_node)
            
            if gen_2_possible:
                print('test moving object to', object_movable_to)
                todo = len(todo_list)
                unique_node = True # assume this node will be unique
                node_IDs[0][0] = agent_movable_to
                original_object_loc = copy.deepcopy(node_IDs[2][0])
                node_IDs[2][0] = object_movable_to
                print('current', node_IDs)
        
                # if this node_IDs state exists in todo states, draw an edge to it
                for n in range(0,len(todo_states)):
                    if node_IDs == todo_states[n]:
                        print('not unique')
                        unique_node = False # say that this node is not unique
                        state_complex.add_edge(x, n, attr='Gen 2') # create an edge to this existing state complex node
                
                # if this node_IDs state doesn't exist, create it and draw an edge
                if unique_node:
                    print('unique')
                    state_complex.add_node(todo, state=copy.deepcopy(node_IDs)) # create the new state complex node node
                    state_complex.add_edge(x, todo, attr='Gen 2') # create an edge from the current node to this new node
                    todo_states.append(copy.deepcopy(node_IDs))
                    todo_list.append(todo)
                
                node_IDs[2][0] = original_object_loc

    step += 1

nx.draw_kamada_kawai(state_complex, width=1.0, alpha=0.5)
plt.axis('off')
plt.savefig("state_complex.png", dpi=300)
plt.show()

# plot states in random walk through state complex

state_num = 0
np.random.seed(1991)

for n in range(0,50):
    state = state_complex.nodes(data=True)[state_num]
    state_labels = state['state']

    node_order = list(world_graph)
    start_order = []
    for j in range(0,len(state_labels[0])):
        start_order.append(node_order.index(state_labels[0][j]))
    goal_order = []
    for j in range(0,len(state_labels[1])):
        goal_order.append(node_order.index(state_labels[1][j]))
    object_order = []
    for j in range(0,len(state_labels[2])):
        object_order.append(node_order.index(state_labels[2][j]))
    wall_order = []
    for j in range(0,len(state_labels[3])):
        wall_order.append(node_order.index(state_labels[3][j]))

    node_colours = []
    for i in range(0,len(WorldArea)):
        node_colours.append(regular_colour)   
    
    for k in start_order:
        node_colours[k] = start_colour
    for k in goal_order:
        node_colours[k] = goal_colour
    for k in object_order:
        node_colours[k] = object_colour
    for k in wall_order:
        node_colours[k] = wall_colour

    plt.figure(1, figsize=(15, 7), dpi=300)
    plt.subplot(121)
    nx.draw_kamada_kawai(state_complex, width=1.0, alpha=0.3)
    nx.draw_kamada_kawai(state_complex, nodelist=[state_num], width=1.0, alpha=1.0)
    plt.subplot(122)
    nx.draw_networkx(world_graph, pos=node_positions, node_color=node_colours, with_labels=False)
    plt.axis('off')
    plt.savefig('gif\state%s.png'% n, dpi=300)
    plt.show()
    
    neighbours = []
    for k in state_complex.neighbors(state_num):
        neighbours.append(k)
        
    state_num = neighbours[np.random.randint(0,len(neighbours))]

# create GIF of random walk
    
gif_name = 'random_walk'
fps = 1
file_list = glob.glob('gif\*.png') # Get all the pngs in the gif directory
file_list = natsorted(file_list) # Sort the images by number
clip = mpy.ImageSequenceClip(file_list, fps=fps)
clip.write_gif('{}.gif'.format(gif_name), fps=fps)